package ethsig

import (
	"crypto/ecdsa"
	"encoding/hex"
	"encoding/json"
	"fmt"
	"os"
	"strings"

	"github.com/ethereum/go-ethereum/accounts/keystore"
	"github.com/ethereum/go-ethereum/crypto"
)

// LoadPrivateKeyFromKeystore loads an Ethereum private key from an encrypted keystore file
// using the provided passphrase. The keystore file should be in the standard Ethereum
// keystore JSON format (as generated by geth, MetaMask, etc.).
func LoadPrivateKeyFromKeystore(keystorePath, passphrase string) (*ecdsa.PrivateKey, error) {
	// Read the keystore file
	data, err := os.ReadFile(keystorePath)
	if err != nil {
		return nil, fmt.Errorf("failed to read keystore file: %w", err)
	}

	// Decrypt the keystore using the passphrase
	key, err := keystore.DecryptKey(data, passphrase)
	if err != nil {
		return nil, fmt.Errorf("failed to decrypt keystore (wrong passphrase?): %w", err)
	}

	return key.PrivateKey, nil
}

// GetAddressFromKeystore returns the Ethereum address from a keystore file without decrypting it.
// This is useful for showing the user which address will be used before asking for the passphrase.
func GetAddressFromKeystore(keystorePath string) (string, error) {
	data, err := os.ReadFile(keystorePath)
	if err != nil {
		return "", fmt.Errorf("failed to read keystore file: %w", err)
	}

	var keyJSON struct {
		Address string `json:"address"`
	}
	if err := json.Unmarshal(data, &keyJSON); err != nil {
		return "", fmt.Errorf("failed to parse keystore JSON: %w", err)
	}

	if keyJSON.Address == "" {
		return "", fmt.Errorf("keystore file does not contain an address field")
	}

	// Ensure it has 0x prefix
	addr := keyJSON.Address
	if !strings.HasPrefix(addr, "0x") {
		addr = "0x" + addr
	}

	return addr, nil
}

// LoadPrivateKeyFromHex loads a private key from a hex-encoded string (with or without 0x prefix).
// This is less secure than using a keystore but useful for testing or when the key is
// stored in an environment variable.
func LoadPrivateKeyFromHex(hexKey string) (*ecdsa.PrivateKey, error) {
	hexKey = strings.TrimPrefix(hexKey, "0x")
	return crypto.HexToECDSA(hexKey)
}

// PrivateKeyToHex converts a private key to a hex-encoded string (without 0x prefix).
func PrivateKeyToHex(key *ecdsa.PrivateKey) string {
	return hex.EncodeToString(crypto.FromECDSA(key))
}

// GetAddressFromPrivateKey returns the Ethereum address corresponding to a private key.
func GetAddressFromPrivateKey(key *ecdsa.PrivateKey) string {
	return crypto.PubkeyToAddress(key.PublicKey).Hex()
}

// CreateKeystore creates a new encrypted keystore file from a private key.
// This is useful for converting a raw private key to a secure keystore format.
func CreateKeystore(key *ecdsa.PrivateKey, passphrase, outputPath string) error {
	// Create a unique ID for the key using a deterministic hash
	hashBytes := crypto.Keccak256(crypto.FromECDSA(key))
	
	// Convert the hash to a UUID format (take first 16 bytes)
	var keyID [16]byte
	copy(keyID[:], hashBytes[:16])
	
	// Encrypt the key with the passphrase using the standard scrypt parameters
	keyJSON, err := keystore.EncryptKey(&keystore.Key{
		Id:         keyID,
		Address:    crypto.PubkeyToAddress(key.PublicKey),
		PrivateKey: key,
	}, passphrase, keystore.StandardScryptN, keystore.StandardScryptP)
	if err != nil {
		return fmt.Errorf("failed to encrypt key: %w", err)
	}

	// Write to file
	if err := os.WriteFile(outputPath, keyJSON, 0600); err != nil {
		return fmt.Errorf("failed to write keystore file: %w", err)
	}

	return nil
}

// GenerateNewKey generates a new random Ethereum private key.
func GenerateNewKey() (*ecdsa.PrivateKey, error) {
	return crypto.GenerateKey()
}
